diff --git a/cmake/avidemuxVersion.cmake b/cmake/avidemuxVersion.cmake
index b3c0f8177..9c9d73da6 100644
--- a/cmake/avidemuxVersion.cmake
+++ b/cmake/avidemuxVersion.cmake
@@ -1,7 +1,7 @@
 #
 #
 #
-SET(RELEASE 1)
+#SET(RELEASE 1)
 #
 #
 include(admTimeStamp)

From 7aa9ce0932ab1f62b10862f4b9a7b587613da267 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Sun, 2 Jan 2022 19:46:49 +0100
Subject: [PATCH 04/11] [ffVaH264,ffVaHEVC] Fix buffer alignment

This patch fixes a crash in av_frame_free() when input video width is not
a multiple of 64.
---
 avidemux_plugins/ADM_videoEncoder/ffVaH264/ADM_ffVAEncH264.cpp | 2 +-
 avidemux_plugins/ADM_videoEncoder/ffVaHEVC/ADM_ffVAEncHEVC.cpp | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/avidemux_plugins/ADM_videoEncoder/ffVaH264/ADM_ffVAEncH264.cpp b/avidemux_plugins/ADM_videoEncoder/ffVaH264/ADM_ffVAEncH264.cpp
index 0987b0288..89974430d 100644
--- a/avidemux_plugins/ADM_videoEncoder/ffVaH264/ADM_ffVAEncH264.cpp
+++ b/avidemux_plugins/ADM_videoEncoder/ffVaH264/ADM_ffVAEncH264.cpp
@@ -211,7 +211,7 @@ bool             ADM_ffVAEncH264Encoder::preEncode(void)
     swFrame->height=source->getInfo()->height;
     swFrame->format=AV_PIX_FMT_NV12;
 
-    int err=av_frame_get_buffer(swFrame, 32);
+    int err=av_frame_get_buffer(swFrame, 64);
     if(err<0)
     {
         CLEARTEXT(err)
diff --git a/avidemux_plugins/ADM_videoEncoder/ffVaHEVC/ADM_ffVAEncHEVC.cpp b/avidemux_plugins/ADM_videoEncoder/ffVaHEVC/ADM_ffVAEncHEVC.cpp
index 843b14992..d196ac9da 100644
--- a/avidemux_plugins/ADM_videoEncoder/ffVaHEVC/ADM_ffVAEncHEVC.cpp
+++ b/avidemux_plugins/ADM_videoEncoder/ffVaHEVC/ADM_ffVAEncHEVC.cpp
@@ -204,7 +204,7 @@ bool ADM_ffVAEncHEVC::preEncode(void)
     swFrame->height=source->getInfo()->height;
     swFrame->format=AV_PIX_FMT_NV12;
 
-    int err=av_frame_get_buffer(swFrame, 32);
+    int err=av_frame_get_buffer(swFrame, 64);
     if(err<0)
     {
         CLEARTEXT(err)

From 4f2d2e12554d42be1933c7a50d0bbe01480bebd0 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Sun, 9 Jan 2022 16:24:04 +0100
Subject: [PATCH 05/11] [demuxers/Matroska] Fix PCM audio track hidden behind
 A_MS/ACM compatibility header misidentified as AAC_LATM

---
 .../ADM_demuxers/Matroska/ADM_mkvEntries.cpp  | 42 +++++++++++++++++--
 1 file changed, 39 insertions(+), 3 deletions(-)

diff --git a/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp b/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp
index 3ba20a63e..8e7ea5a97 100644
--- a/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp
+++ b/avidemux_plugins/ADM_demuxers/Matroska/ADM_mkvEntries.cpp
@@ -307,14 +307,50 @@ uint8_t mkvHeader::analyzeOneTrack(void *head,uint32_t headlen)
                 wavSize+=2; // size of WAVEFORMATEX
                 int x=l-wavSize;
 
-                if(x>0) // If we have more than WAVEFORMATEX, it is extradata
+                if(t->wavHeader.encoding == 0xfffe) // WAVEFORMATEXTENSIBLE
+                {
+                    if(l < 40)
+                    {
+                        ADM_warning("Not enough data for WAVEFORMATEXTENSIBLE header, need 40, got %d, skipping track.\n",l);
+                        delete [] entry.extraData;
+                        return 0;
+                    }
+                    uint8_t *ptr = entry.extraData;
+                    ptr += wavSize + 6; // offset of GUID
+                    typedef struct { uint32_t data1; uint16_t data2; uint16_t data3; uint8_t data4[8]; } msGuid;
+                    typedef struct { uint16_t tag; msGuid guid; } tag2guid;
+#define NB_GUIDS 6
+                    const tag2guid supportedGuids[NB_GUIDS] = {
+                        { WAV_PCM,      { 0x1,0x0,0x10, { 0x80,0x0,0x0,0xaa,0x0,0x38,0x9b,0x71 } } /* KSDATAFORMAT_SUBTYPE_PCM */ },
+                        { WAV_MSADPCM,  { 0x2,0x0,0x10, { 0x80,0x0,0x0,0xaa,0x0,0x38,0x9b,0x71 } } /* KSDATAFORMAT_SUBTYPE_ADPCM */ },
+                        { WAV_ULAW,     { 0x7,0x0,0x10, { 0x80,0x0,0x0,0xaa,0x0,0x38,0x9b,0x71 } } /* KSDATAFORMAT_SUBTYPE_MULAW */ },
+                        { WAV_LPCM,     { 0xe06d8032,0xdb46,0x11cf, { 0xb4,0xd1,0x0,0x80,0x5f,0x6c,0xbb,0xea } } /* KSDATAFORMAT_SUBTYPE_LPCM_AUDIO */ },
+                        { WAV_AC3,      { 0xe06d802c,0xdb46,0x11cf, { 0xb4,0xd1,0x0,0x80,0x5f,0x6c,0xbb,0xea } } /* KSDATAFORMAT_SUBTYPE_AC3_AUDIO */ },
+                        { WAV_MP2,      { 0xe06d802b,0xdb46,0x11cf, { 0xb4,0xd1,0x0,0x80,0x5f,0x6c,0xbb,0xea } } /* ,KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO */ }
+                    };
+                    for(int i=0; i < NB_GUIDS; i++)
+                    {
+                        const msGuid *v1 = (msGuid *)ptr;
+                        const msGuid *v2 = &(supportedGuids[i].guid);
+                        if(v1->data1 == v2->data1 && v1->data2 == v2->data2 && !memcmp(v1->data4,v2->data4,8))
+                        {
+                            t->wavHeader.encoding = supportedGuids[i].tag;
+                            ADM_info("Encoding set from SubFormat GUID to 0x%x (%s)\n",t->wavHeader.encoding,getStrFromAudioCodec(t->wavHeader.encoding));
+                            break;
+                        }
+                    }
+                    if(t->wavHeader.encoding == 0xfffe) // unassigned
+                    {
+                        ADM_warning("SubFormat GUID not recognized, skipping track.\n");
+                        delete [] entry.extraData;
+                        return 0;
+                    }
+                }else if(x>0) // If we have more than WAVEFORMATEX but no WAVEFORMATEXTENSIBLE tag, it is extradata
                 {
                     ADM_info("Found %d bytes of extradata\n",x);
                     t->extraData=new uint8_t[x];
                     t->extraDataLen=x;
                     memcpy(t->extraData,entry.extraData+wavSize,x);
-                    if(t->wavHeader.encoding==0xfffe) // WAVE_FORMAT_EXTENSIBLE + extradata: might be AAC LATM
-                        t->wavHeader.encoding=MKV_MUX_LATM;
                 }
                 if(t->wavHeader.encoding==MKV_MUX_LATM)
                 {

From a3f0547bffbe8f2b924aa9a123981f637a92ae2a Mon Sep 17 00:00:00 2001
From: adam <szullo.adam@gmail.com>
Date: Thu, 30 Dec 2021 03:07:34 +0100
Subject: [PATCH 06/11] [Q_gui2] event handler only query preference if
 relevant

---
 avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp b/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
index 411c71c07..00229aca8 100644
--- a/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
+++ b/avidemux/qt4/ADM_userInterfaces/ADM_gui/Q_gui2.cpp
@@ -1756,12 +1756,12 @@ bool MainWindow::eventFilter(QObject* watched, QEvent* event)
 {
     QKeyEvent *keyEvent;
     bool swpud=false;
-    prefs->get(KEYBOARD_SHORTCUTS_SWAP_UP_DOWN_KEYS,&swpud);
+    
     switch (event->type())
     {
         case QEvent::KeyPress:
             keyEvent = (QKeyEvent*)event;
-
+            prefs->get(KEYBOARD_SHORTCUTS_SWAP_UP_DOWN_KEYS,&swpud);
 //            if (watched == slider)
             {
                 switch (keyEvent->key())

From 5afb2224a19d739b2d33519740ab6ebcd9bda53d Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Wed, 5 Jan 2022 22:35:37 +0100
Subject: [PATCH 07/11] [editor] Do not reset frame counter before checking PTS
 validity

Feeding already consumed frames to decoder may result in decoded pictures
output in wrong order and bogus detection of PTS going back.
---
 .../common/ADM_editor/src/utils/ADM_edCheckForInvalidPts.cpp    | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/avidemux/common/ADM_editor/src/utils/ADM_edCheckForInvalidPts.cpp b/avidemux/common/ADM_editor/src/utils/ADM_edCheckForInvalidPts.cpp
index b95d0340e..25be6e8c6 100644
--- a/avidemux/common/ADM_editor/src/utils/ADM_edCheckForInvalidPts.cpp
+++ b/avidemux/common/ADM_editor/src/utils/ADM_edCheckForInvalidPts.cpp
@@ -50,7 +50,7 @@ bool ADM_Composer::checkForValidPts (_SEGMENT *seg)
         ADM_warning("Cannot navigate, cannot check file for broken PTS.\n");
         return false;
     }
-    vid->lastSentFrame=0;
+    //vid->lastSentFrame=0; // We may not touch this counter here else we confuse the decoder, esp. with MT enabled.
     vid->dontTrustBFramePts=false;
     uint64_t inc=vid->timeIncrementInUs;
 

From b34a5061fa8519cd714425302bf2061f7d9c1653 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Fri, 14 Jan 2022 01:16:23 +0100
Subject: [PATCH 08/11] [editor/segment] Fix crash copying to clipboard when
 selection extends to the end of video

Also fix another case where the return value of convertLinearTimeToSeg()
was not evaluated.

The crash was a regression from ea533ab04e25f2cf903d2538685047b64eb4fcd7.
---
 .../common/ADM_editor/src/ADM_segment.cpp     | 26 ++++++++++++++-----
 1 file changed, 20 insertions(+), 6 deletions(-)

diff --git a/avidemux/common/ADM_editor/src/ADM_segment.cpp b/avidemux/common/ADM_editor/src/ADM_segment.cpp
index f0b7b520f..da87c5d22 100644
--- a/avidemux/common/ADM_editor/src/ADM_segment.cpp
+++ b/avidemux/common/ADM_editor/src/ADM_segment.cpp
@@ -1094,12 +1094,21 @@ bool        ADM_EditorSegment::LinearToRefTime(int segNo,uint64_t linear,uint64_
  */
 bool        ADM_EditorSegment::copyToClipBoard(uint64_t startTime, uint64_t endTime)
 {
-    ADM_info("Copy to clipboard from %s",ADM_us2plain(startTime));
-    ADM_info("to %s\n",ADM_us2plain(endTime));
+    char *plainStart = ADM_strdup(ADM_us2plain(startTime));
+    ADM_info("Copying from %s to %s\n",plainStart,ADM_us2plain(endTime));
+    ADM_dealloc(plainStart);
+    plainStart = NULL;
     uint32_t startSeg,endSeg;
     uint64_t startSegTime,endSegTime;
-    convertLinearTimeToSeg(  startTime, &startSeg,&startSegTime);
-    convertLinearTimeToSeg(  endTime, &endSeg,&endSegTime);
+    if(false == convertLinearTimeToSeg(startTime, &startSeg, &startSegTime))
+        return false;
+    uint64_t total = getTotalDuration();
+    if(endTime >= total)
+    {
+        endSeg = getNbSegments() - 1;
+        endTime = total;
+    }else if(false == convertLinearTimeToSeg(endTime, &endSeg, &endSegTime))
+        return false;
     dump();
     clipboard.clear();
     for(int seg=startSeg;seg<=endSeg;seg++)
@@ -1154,8 +1163,13 @@ bool        ADM_EditorSegment::pasteFromClipBoard(uint64_t currentTime)
     }
     ADM_info("Pasting from clipboard to %s\n",ADM_us2plain(currentTime));
     uint32_t startSeg;
-    uint64_t startSegTime;
-    convertLinearTimeToSeg(  currentTime, &startSeg,&startSegTime);    
+    uint64_t startSegTime, total = getTotalDuration();
+    if(currentTime >= total)
+    {
+        startSeg = getNbSegments() - 1;
+        currentTime = total;
+    }else if(false == convertLinearTimeToSeg(currentTime, &startSeg, &startSegTime))
+        return false;
     ListOfSegments tmp=segments;
     ListOfSegments newSegs;
     int n=segments.size();

From ba465b8353d7bb494df79e65e9911c5001b88725 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Mon, 31 Jan 2022 15:59:27 +0100
Subject: [PATCH 09/11] [cmake,muxerGate] Fix muxing ISO HEVC streams into
 MPEG-TS in copy mode

---
 .../src/ADM_videoCopyFromAnnexB.cpp           | 19 ++++++++-----------
 cmake/admFFmpegBuild_helpers.cmake            |  2 +-
 2 files changed, 9 insertions(+), 12 deletions(-)

diff --git a/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp b/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
index 18066f891..2ee7f6d64 100644
--- a/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
+++ b/avidemux/common/ADM_muxerGate/src/ADM_videoCopyFromAnnexB.cpp
@@ -426,18 +426,16 @@ ADM_videoStreamCopyToAnnexB::ADM_videoStreamCopyToAnnexB(uint64_t startTime,uint
     
     myExtra=NULL;
     myExtraLen=0;
-    
-    AVCodec *codec=avcodec_find_decoder(AV_CODEC_ID_H264);
+
+    AVCodec *codec = avcodec_find_decoder(isH265Compatible(fourCC) ? AV_CODEC_ID_HEVC : AV_CODEC_ID_H264);
     ADM_assert(codec);
     AVCodecContext *context = avcodec_alloc_context3(codec);
     ADM_assert(context);
-    
-    aviInfo info;
-    video_body->getVideoInfo(&info);
-    context->width = info.width;
-    context->height = info.height;
-    context->pix_fmt = AV_PIX_FMT_YUV420P;
-    
+
+    context->width = width;
+    context->height = height;
+    context->pix_fmt = AV_PIX_FMT_YUV420P; // dummy
+
     video_body->getExtraHeaderData(&extraLen,&extraData);
     // duplicate extraData with malloc scheme, it will be freed by the bitstream filter
     context->extradata=(uint8_t*)av_malloc(extraLen);
@@ -447,9 +445,8 @@ ADM_videoStreamCopyToAnnexB::ADM_videoStreamCopyToAnnexB(uint64_t startTime,uint
     
 // #warning  Ok, should we open the codec by itself ?
 
-    
     AVBitStreamFilterContext *bsf;
-    bsf = av_bitstream_filter_init("h264_mp4toannexb");
+    bsf = av_bitstream_filter_init(isH265Compatible(fourCC) ? "hevc_mp4toannexb" : "h264_mp4toannexb");
     ADM_assert(bsf);
     bsfContext=bsf;
     ADM_info("Copy to annexB initialized\n");
diff --git a/cmake/admFFmpegBuild_helpers.cmake b/cmake/admFFmpegBuild_helpers.cmake
index 40796ef49..908ea7102 100644
--- a/cmake/admFFmpegBuild_helpers.cmake
+++ b/cmake/admFFmpegBuild_helpers.cmake
@@ -36,7 +36,7 @@ set(FFMPEG_PARSERS      ac3  h263  h264  hevc  mpeg4video)
 
 set(FFMPEG_PROTOCOLS    file)
 
-set(FFMPEG_BSFS         h264_mp4toannexb aac_adtstoasc)
+set(FFMPEG_BSFS         h264_mp4toannexb hevc_mp4toannexb aac_adtstoasc)
 
 #
 #

From a736ee9b33ca358b3fc358dc5977b1f9ebae3af5 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Fri, 4 Feb 2022 12:56:27 +0100
Subject: [PATCH 10/11] [editor] Untie post-processing from availability of
 quantization info

---
 .../ADM_editor/src/ADM_edRenderInternal.cpp   | 26 +++++++++----------
 1 file changed, 12 insertions(+), 14 deletions(-)

diff --git a/avidemux/common/ADM_editor/src/ADM_edRenderInternal.cpp b/avidemux/common/ADM_editor/src/ADM_edRenderInternal.cpp
index c734ed7ec..2ad75d8ea 100644
--- a/avidemux/common/ADM_editor/src/ADM_edRenderInternal.cpp
+++ b/avidemux/common/ADM_editor/src/ADM_edRenderInternal.cpp
@@ -404,19 +404,9 @@ bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t
         return true;
     }
     aprintf("[::Decompress] in:%" PRIu64" out:%" PRIu64" flags:%x\n",in->demuxerPts,out->Pts,out->flags);
-    // If not quant and it is already YV12, we can stop here
-    // Also, if the image is decoded through hw, dont do post proc
-    if(tmpImage->refType!=ADM_HW_NONE || ((!tmpImage->quant || !tmpImage->_qStride) && tmpImage->_pixfrmt==ADM_PIXFRMT_YV12))
-    {
-        out->duplicate(tmpImage);
-        aprintf("[decompressImage] : No quant avail\n");
-        return true;
-    }
     // We got everything, let's go
-    // Dupe infos
-    out->copyInfo(tmpImage);
-    // 1 compute average quant
-    if(tmpImage->_Qp == ADM_IMAGE_UNKNOWN_QP && tmpImage->_qSize)
+    // If we have quant but no _Qp from decoder, compute average
+    if(tmpImage->_Qp == ADM_IMAGE_UNKNOWN_QP && tmpImage->_qSize && tmpImage->quant)
     {
         int qz;
         uint32_t z, sumit = 0;
@@ -433,15 +423,23 @@ bool ADM_Composer::decompressImage(ADMImage *out,ADMCompressedImage *in,uint32_t
         // update average Q
         tmpImage->_Qp=out->_Qp=(uint32_t)floor(sum);
     }
-
+    // If the image is decoded through hw, dont do post proc
+    if(tmpImage->refType != ADM_HW_NONE)
+    {
+        out->duplicate(tmpImage);
+        aprintf("[decompressImage] : hw pic\n");
+        return true;
+    }
     // Do postprocessing if any
     // Pp deactivated ?
     if(!_pp->postProcType || !_pp->postProcStrength || tmpImage->_pixfrmt!=ADM_PIXFRMT_YV12)
     {
         dupe(tmpImage,out,v);
-        aprintf("EdCache: Postproc disabled\n");
+        aprintf("[decompressImage] Skipping post-processing because %s\n", (tmpImage->_pixfrmt != ADM_PIXFRMT_YV12) ? "not YV12" : "it is disabled");
         return true;
     }
+    // Dupe infos
+    out->copyInfo(tmpImage);
     /* Do it!*/
     _pp->process(tmpImage,out);
     return true;

From 7293b9c7cde49d80be1cb5a5b4f67b32ef1dd930 Mon Sep 17 00:00:00 2001
From: eumagga0x2a <eumagga0x2a@users.noreply.github.com>
Date: Sat, 5 Feb 2022 21:09:34 +0100
Subject: [PATCH 11/11] [i18n] Pull in updated Japanese and French translations

---
 avidemux/qt4/i18n | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

